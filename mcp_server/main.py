# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T11:47:32+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    AcceptAdministratorInvitationResponse,
    AcceptInvitationResponse,
    AdminDisablePostRequest,
    AdminEnablePostRequest,
    ArchiveFindingsResponse,
    BadRequestException,
    CreateDetectorResponse,
    CreateFilterResponse,
    CreateIPSetResponse,
    CreateMembersResponse,
    CreatePublishingDestinationResponse,
    CreateSampleFindingsResponse,
    CreateThreatIntelSetResponse,
    DeclineInvitationsResponse,
    DeleteDetectorResponse,
    DeleteFilterResponse,
    DeleteInvitationsResponse,
    DeleteIPSetResponse,
    DeleteMembersResponse,
    DeletePublishingDestinationResponse,
    DeleteThreatIntelSetResponse,
    DescribeMalwareScansResponse,
    DescribeOrganizationConfigurationResponse,
    DescribePublishingDestinationResponse,
    DetectorDetectorIdAdministratorPostRequest,
    DetectorDetectorIdAdminPostRequest,
    DetectorDetectorIdCoveragePostRequest,
    DetectorDetectorIdCoverageStatisticsPostRequest,
    DetectorDetectorIdFilterFilterNamePostRequest,
    DetectorDetectorIdFilterPostRequest,
    DetectorDetectorIdFindingsArchivePostRequest,
    DetectorDetectorIdFindingsCreatePostRequest,
    DetectorDetectorIdFindingsFeedbackPostRequest,
    DetectorDetectorIdFindingsGetPostRequest,
    DetectorDetectorIdFindingsPostRequest,
    DetectorDetectorIdFindingsStatisticsPostRequest,
    DetectorDetectorIdFindingsUnarchivePostRequest,
    DetectorDetectorIdFreeTrialDaysRemainingPostRequest,
    DetectorDetectorIdIpsetIpSetIdPostRequest,
    DetectorDetectorIdIpsetPostRequest,
    DetectorDetectorIdMalwareScanSettingsPostRequest,
    DetectorDetectorIdMalwareScansPostRequest,
    DetectorDetectorIdMasterPostRequest,
    DetectorDetectorIdMemberDeletePostRequest,
    DetectorDetectorIdMemberDetectorGetPostRequest,
    DetectorDetectorIdMemberDetectorUpdatePostRequest,
    DetectorDetectorIdMemberDisassociatePostRequest,
    DetectorDetectorIdMemberGetPostRequest,
    DetectorDetectorIdMemberInvitePostRequest,
    DetectorDetectorIdMemberPostRequest,
    DetectorDetectorIdMemberStartPostRequest,
    DetectorDetectorIdMemberStopPostRequest,
    DetectorDetectorIdPostRequest,
    DetectorDetectorIdPublishingDestinationDestinationIdPostRequest,
    DetectorDetectorIdPublishingDestinationPostRequest,
    DetectorDetectorIdThreatintelsetPostRequest,
    DetectorDetectorIdThreatintelsetThreatIntelSetIdPostRequest,
    DetectorDetectorIdUsageStatisticsPostRequest,
    DetectorPostRequest,
    DisableOrganizationAdminAccountResponse,
    DisassociateFromAdministratorAccountResponse,
    DisassociateFromMasterAccountResponse,
    DisassociateMembersResponse,
    EnableOrganizationAdminAccountResponse,
    GetAdministratorAccountResponse,
    GetCoverageStatisticsResponse,
    GetDetectorResponse,
    GetFilterResponse,
    GetFindingsResponse,
    GetFindingsStatisticsResponse,
    GetInvitationsCountResponse,
    GetIPSetResponse,
    GetMalwareScanSettingsResponse,
    GetMasterAccountResponse,
    GetMemberDetectorsResponse,
    GetMembersResponse,
    GetRemainingFreeTrialDaysResponse,
    GetThreatIntelSetResponse,
    GetUsageStatisticsResponse,
    InternalServerErrorException,
    InvitationDeclinePostRequest,
    InvitationDeletePostRequest,
    InviteMembersResponse,
    ListCoverageResponse,
    ListDetectorsResponse,
    ListFiltersResponse,
    ListFindingsResponse,
    ListInvitationsResponse,
    ListIPSetsResponse,
    ListMembersResponse,
    ListOrganizationAdminAccountsResponse,
    ListPublishingDestinationsResponse,
    ListTagsForResourceResponse,
    ListThreatIntelSetsResponse,
    StartMonitoringMembersResponse,
    StopMonitoringMembersResponse,
    TagKeys,
    TagResourceResponse,
    TagsResourceArnPostRequest,
    UnarchiveFindingsResponse,
    UntagResourceResponse,
    UpdateDetectorResponse,
    UpdateFilterResponse,
    UpdateFindingsFeedbackResponse,
    UpdateIPSetResponse,
    UpdateMalwareScanSettingsResponse,
    UpdateMemberDetectorsResponse,
    UpdateOrganizationConfigurationResponse,
    UpdatePublishingDestinationResponse,
    UpdateThreatIntelSetResponse,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='<p>Amazon GuardDuty is a continuous security monitoring service that analyzes and processes the following data sources: VPC flow logs, Amazon Web Services CloudTrail management event logs, CloudTrail S3 data event logs, EKS audit logs, DNS logs, and Amazon EBS volume data. It uses threat intelligence feeds, such as lists of malicious IPs and domains, and machine learning to identify unexpected, potentially unauthorized, and malicious activity within your Amazon Web Services environment. This can include issues like escalations of privileges, uses of exposed credentials, or communication with malicious IPs, domains, or presence of malware on your Amazon EC2 instances and container workloads. For example, GuardDuty can detect compromised EC2 instances and container workloads serving malware, or mining bitcoin. </p> <p>GuardDuty also monitors Amazon Web Services account access behavior for signs of compromise, such as unauthorized infrastructure deployments like EC2 instances deployed in a Region that has never been used, or unusual API calls like a password policy change to reduce password strength. </p> <p>GuardDuty informs you about the status of your Amazon Web Services environment by producing security findings that you can view in the GuardDuty console or through Amazon EventBridge. For more information, see the <i> <a href="https://docs.aws.amazon.com/guardduty/latest/ug/what-is-guardduty.html">Amazon GuardDuty User Guide</a> </i>. </p>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='Amazon GuardDuty',
    version='2017-11-28',
    servers=[
        {
            'description': 'The Amazon GuardDuty multi-region endpoint',
            'url': 'http://guardduty.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Amazon GuardDuty multi-region endpoint',
            'url': 'https://guardduty.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Amazon GuardDuty endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://guardduty.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The Amazon GuardDuty endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://guardduty.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/admin',
    description=""" Lists the accounts configured as GuardDuty delegated administrators. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'finding_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_organization_admin_accounts(
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/admin/disable',
    description=""" Disables an Amazon Web Services account within the Organization as the GuardDuty delegated administrator. """,
    tags=['organization_admin_account_management', 'member_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disable_organization_admin_account(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: AdminDisablePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/admin/enable',
    description=""" Enables an Amazon Web Services account within the organization as the GuardDuty delegated administrator. """,
    tags=[
        'organization_admin_account_management',
        'master_account_management',
        'member_account_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def enable_organization_admin_account(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: AdminEnablePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector',
    description=""" Lists detectorIds of all the existing Amazon GuardDuty detector resources. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'coverage_data_management',
        'finding_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_detectors(
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector',
    description=""" <p>Creates a single Amazon GuardDuty detector. A detector is a resource that represents the GuardDuty service. To start using GuardDuty, you must create a detector in each Region where you enable the service. You can have only one detector per account per Region. All data sources are enabled in a new detector by default.</p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_detector(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/detector/{detectorId}',
    description=""" Deletes an Amazon GuardDuty detector that is specified by the detector ID. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_detector(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}',
    description=""" <p>Retrieves an Amazon GuardDuty detector specified by the detectorId.</p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_detector(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}',
    description=""" <p>Updates the Amazon GuardDuty detector specified by the detectorId.</p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_detector(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/admin',
    description=""" <p>Returns information about the account selected as the delegated administrator for GuardDuty.</p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=[
        'detector_management',
        'coverage_data_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_organization_configuration(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/admin',
    description=""" <p>Configures the delegated administrator account with the provided values. You must provide the value for either <code>autoEnableOrganizationMembers</code> or <code>autoEnable</code>. </p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_organization_configuration(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdAdminPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/administrator',
    description=""" Provides the details for the GuardDuty administrator account associated with the current GuardDuty member account. """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_administrator_account(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/administrator',
    description=""" Accepts the invitation to be a member account and get monitored by a GuardDuty administrator account that sent the invitation. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'member_account_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def accept_administrator_invitation(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdAdministratorPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/administrator/disassociate',
    description=""" <p>Disassociates the current GuardDuty member account from its administrator account.</p> <p>With <code>autoEnableOrganizationMembers</code> configuration for your organization set to <code>ALL</code>, you'll receive an error if you attempt to disable GuardDuty in a member account.</p> """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_from_administrator_account(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/coverage',
    description=""" <p>Lists coverage details for your GuardDuty account. If you're a GuardDuty administrator, you can retrieve all resources associated with the active member accounts in your organization.</p> <p>Make sure the accounts have EKS Runtime Monitoring enabled and GuardDuty agent running on their EKS nodes.</p> """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'coverage_data_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_coverage(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdCoveragePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/coverage/statistics',
    description=""" Retrieves aggregated statistics for your account. If you are a GuardDuty administrator, you can retrieve the statistics for all the resources associated with the active member accounts in your organization who have enabled EKS Runtime Monitoring and have the GuardDuty agent running on their EKS nodes. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'coverage_data_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_coverage_statistics(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdCoverageStatisticsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/filter',
    description=""" Returns a paginated list of the current filters. """,
    tags=['detector_management', 'detector_usage_statistics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_filters(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/filter',
    description=""" Creates a filter using the specified finding criteria. The maximum number of saved filters per Amazon Web Services account per Region is 100. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_limits.html">Quotas for GuardDuty</a>. """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_filter(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFilterPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/detector/{detectorId}/filter/{filterName}',
    description=""" Deletes the filter specified by the filter name. """,
    tags=['detector_management', 'filter_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_filter(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    filter_name: str = Path(..., alias='filterName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/filter/{filterName}',
    description=""" Returns the details of the filter specified by the filter name. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'filter_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_filter(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    filter_name: str = Path(..., alias='filterName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/filter/{filterName}',
    description=""" Updates the filter specified by the filter name. """,
    tags=[
        'detector_management',
        'filter_management',
        'detector_configuration_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_filter(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    filter_name: str = Path(..., alias='filterName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFilterFilterNamePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/findings',
    description=""" Lists Amazon GuardDuty findings for the specified detector ID. """,
    tags=['detector_management', 'finding_management', 'detector_usage_statistics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_findings(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFindingsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/findings/archive',
    description=""" <p>Archives GuardDuty findings that are specified by the list of finding IDs.</p> <note> <p>Only the administrator account can archive findings. Member accounts don't have permission to archive findings from their accounts.</p> </note> """,
    tags=['detector_management', 'finding_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def archive_findings(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFindingsArchivePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/findings/create',
    description=""" Generates sample findings of types specified by the list of finding types. If 'NULL' is specified for <code>findingTypes</code>, the API generates sample findings of all supported finding types. """,
    tags=['detector_management', 'finding_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_sample_findings(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFindingsCreatePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/findings/feedback',
    description=""" Marks the specified GuardDuty findings as useful or not useful. """,
    tags=[
        'detector_management',
        'finding_management',
        'detector_configuration_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_findings_feedback(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFindingsFeedbackPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/findings/get',
    description=""" Describes Amazon GuardDuty findings specified by finding IDs. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'finding_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_findings(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFindingsGetPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/findings/statistics',
    description=""" Lists Amazon GuardDuty findings statistics for the specified detector ID. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'coverage_data_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_findings_statistics(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFindingsStatisticsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/findings/unarchive',
    description=""" Unarchives GuardDuty findings specified by the <code>findingIds</code>. """,
    tags=['detector_management', 'finding_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def unarchive_findings(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFindingsUnarchivePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/freeTrial/daysRemaining',
    description=""" Provides the number of days left for each data source used in the free trial period. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_remaining_free_trial_days(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdFreeTrialDaysRemainingPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/ipset',
    description=""" Lists the IPSets of the GuardDuty service specified by the detector ID. If you use this operation from a member account, the IPSets returned are the IPSets from the associated administrator account. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'coverage_data_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_i_p_sets(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/ipset',
    description=""" Creates a new IPSet, which is called a trusted IP list in the console user interface. An IPSet is a list of IP addresses that are trusted for secure communication with Amazon Web Services infrastructure and applications. GuardDuty doesn't generate findings for IP addresses that are included in IPSets. Only users from the administrator account can use this operation. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'ip_set_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_i_p_set(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdIpsetPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/detector/{detectorId}/ipset/{ipSetId}',
    description=""" Deletes the IPSet specified by the <code>ipSetId</code>. IPSets are called trusted IP lists in the console user interface. """,
    tags=['detector_management', 'ip_set_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_i_p_set(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    ip_set_id: str = Path(..., alias='ipSetId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/ipset/{ipSetId}',
    description=""" Retrieves the IPSet specified by the <code>ipSetId</code>. """,
    tags=['detector_management', 'ip_set_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_i_p_set(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    ip_set_id: str = Path(..., alias='ipSetId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/ipset/{ipSetId}',
    description=""" Updates the IPSet specified by the IPSet ID. """,
    tags=['detector_management', 'ip_set_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_i_p_set(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    ip_set_id: str = Path(..., alias='ipSetId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdIpsetIpSetIdPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/malware-scan-settings',
    description=""" <p>Returns the details of the malware scan settings.</p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_malware_scan_settings(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/malware-scan-settings',
    description=""" <p>Updates the malware scan settings.</p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=['detector_management', 'malware_scan_settings_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_malware_scan_settings(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMalwareScanSettingsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/malware-scans',
    description=""" <p>Returns a list of malware scans. Each member account can view the malware scans for their own accounts. An administrator can view the malware scans for all the member accounts.</p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=['detector_management', 'malware_scan_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_malware_scans(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMalwareScansPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/master',
    description=""" Provides the details for the GuardDuty administrator account associated with the current GuardDuty member account. """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_master_account(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/master',
    description=""" Accepts the invitation to be monitored by a GuardDuty administrator account. """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def accept_invitation(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMasterPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/master/disassociate',
    description=""" Disassociates the current GuardDuty member account from its administrator account. """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_from_master_account(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/member',
    description=""" Lists details about all member accounts for the current GuardDuty administrator account. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'coverage_data_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_members(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    only_associated: Optional[str] = Query(None, alias='onlyAssociated'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/member',
    description=""" <p>Creates member accounts of the current Amazon Web Services account by specifying a list of Amazon Web Services account IDs. This step is a prerequisite for managing the associated member accounts either by invitation or through an organization.</p> <p>When using <code>Create Members</code> as an organizations delegated administrator this action will enable GuardDuty in the added member accounts, with the exception of the organization delegated administrator account, which must enable GuardDuty prior to being added as a member.</p> <p>If you are adding accounts by invitation, use this action after GuardDuty has bee enabled in potential member accounts and before using <a href="https://docs.aws.amazon.com/guardduty/latest/APIReference/API_InviteMembers.html">InviteMembers</a>.</p> """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'member_account_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_members(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMemberPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/member/delete',
    description=""" <p>Deletes GuardDuty member accounts (to the current GuardDuty administrator account) specified by the account IDs.</p> <p>With <code>autoEnableOrganizationMembers</code> configuration for your organization set to <code>ALL</code>, you'll receive an error if you attempt to disable GuardDuty for a member account in your organization.</p> """,
    tags=['detector_management', 'member_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_members(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMemberDeletePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/member/detector/get',
    description=""" <p>Describes which data sources are enabled for the member account's detector.</p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_member_detectors(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMemberDetectorGetPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/member/detector/update',
    description=""" <p>Contains information on member accounts to be updated.</p> <p>There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html">Regions and endpoints</a>.</p> """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'member_account_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_member_detectors(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMemberDetectorUpdatePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/member/disassociate',
    description=""" <p>Disassociates GuardDuty member accounts (to the current administrator account) specified by the account IDs.</p> <p>With <code>autoEnableOrganizationMembers</code> configuration for your organization set to <code>ALL</code>, you'll receive an error if you attempt to disassociate a member account before removing them from your Amazon Web Services organization.</p> """,
    tags=['detector_management', 'member_account_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_members(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMemberDisassociatePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/member/get',
    description=""" Retrieves GuardDuty member accounts (of the current GuardDuty administrator account) specified by the account IDs. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'member_account_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_members(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMemberGetPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/member/invite',
    description=""" Invites other Amazon Web Services accounts (created as members of the current Amazon Web Services account by CreateMembers) to enable GuardDuty, and allow the current Amazon Web Services account to view and manage these accounts' findings on their behalf as the GuardDuty administrator account. """,
    tags=['detector_management', 'member_account_management', 'invitation_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def invite_members(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMemberInvitePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/member/start',
    description=""" Turns on GuardDuty monitoring of the specified member accounts. Use this operation to restart monitoring of accounts that you stopped monitoring with the <a href="https://docs.aws.amazon.com/guardduty/latest/APIReference/API_StopMonitoringMembers.html">StopMonitoringMembers</a> operation. """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_monitoring_members(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMemberStartPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/member/stop',
    description=""" <p>Stops GuardDuty monitoring for the specified member accounts. Use the <code>StartMonitoringMembers</code> operation to restart monitoring for those accounts.</p> <p>With <code>autoEnableOrganizationMembers</code> configuration for your organization set to <code>ALL</code>, you'll receive an error if you attempt to stop monitoring the member accounts in your organization.</p> """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def stop_monitoring_members(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdMemberStopPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/publishingDestination',
    description=""" Returns a list of publishing destinations associated with the specified <code>detectorId</code>. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'coverage_data_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_publishing_destinations(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/publishingDestination',
    description=""" Creates a publishing destination to export findings to. The resource to export findings to must exist before you use this operation. """,
    tags=['detector_management', 'publishing_destination_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_publishing_destination(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdPublishingDestinationPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/detector/{detectorId}/publishingDestination/{destinationId}',
    description=""" Deletes the publishing definition with the specified <code>destinationId</code>. """,
    tags=['detector_management', 'publishing_destination_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_publishing_destination(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    destination_id: str = Path(..., alias='destinationId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/publishingDestination/{destinationId}',
    description=""" Returns information about the publishing destination specified by the provided <code>destinationId</code>. """,
    tags=['detector_management', 'publishing_destination_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_publishing_destination(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    destination_id: str = Path(..., alias='destinationId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/publishingDestination/{destinationId}',
    description=""" Updates information about the publishing destination specified by the <code>destinationId</code>. """,
    tags=['detector_management', 'publishing_destination_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_publishing_destination(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    destination_id: str = Path(..., alias='destinationId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdPublishingDestinationDestinationIdPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/threatintelset',
    description=""" Lists the ThreatIntelSets of the GuardDuty service specified by the detector ID. If you use this operation from a member account, the ThreatIntelSets associated with the administrator account are returned. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'coverage_data_management',
        'detector_usage_statistics',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_threat_intel_sets(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/threatintelset',
    description=""" Creates a new ThreatIntelSet. ThreatIntelSets consist of known malicious IP addresses. GuardDuty generates findings based on ThreatIntelSets. Only users of the administrator account can use this operation. """,
    tags=['detector_management', 'threat_intelligence_set_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_threat_intel_set(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdThreatintelsetPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/detector/{detectorId}/threatintelset/{threatIntelSetId}',
    description=""" Deletes the ThreatIntelSet specified by the ThreatIntelSet ID. """,
    tags=['detector_management', 'threat_intelligence_set_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_threat_intel_set(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    threat_intel_set_id: str = Path(..., alias='threatIntelSetId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detector/{detectorId}/threatintelset/{threatIntelSetId}',
    description=""" Retrieves the ThreatIntelSet that is specified by the ThreatIntelSet ID. """,
    tags=['detector_management', 'threat_intelligence_set_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_threat_intel_set(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    threat_intel_set_id: str = Path(..., alias='threatIntelSetId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/threatintelset/{threatIntelSetId}',
    description=""" Updates the ThreatIntelSet specified by the ThreatIntelSet ID. """,
    tags=['detector_management', 'threat_intelligence_set_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_threat_intel_set(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    threat_intel_set_id: str = Path(..., alias='threatIntelSetId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdThreatintelsetThreatIntelSetIdPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/detector/{detectorId}/usage/statistics',
    description=""" Lists Amazon GuardDuty usage statistics over the last 30 days for the specified detector ID. For newly enabled detectors or data sources, the cost returned will include only the usage so far under 30 days. This may differ from the cost metrics in the console, which project usage over 30 days to provide a monthly cost estimate. For more information, see <a href="https://docs.aws.amazon.com/guardduty/latest/ug/monitoring_costs.html#usage-calculations">Understanding How Usage Costs are Calculated</a>. """,
    tags=['detector_usage_statistics', 'detector_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_usage_statistics(
    detector_id: constr(min_length=1, max_length=300) = Path(..., alias='detectorId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DetectorDetectorIdUsageStatisticsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/invitation',
    description=""" Lists all GuardDuty membership invitations that were sent to the current Amazon Web Services account. """,
    tags=['detector_management', 'coverage_data_management', 'finding_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_invitations(
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/invitation/count',
    description=""" Returns the count of all GuardDuty membership invitations that were sent to the current member account except the currently accepted invitation. """,
    tags=['detector_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_invitations_count(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invitation/decline',
    description=""" Declines invitations sent to the current member account by Amazon Web Services accounts specified by their account IDs. """,
    tags=['invitation_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def decline_invitations(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: InvitationDeclinePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invitation/delete',
    description=""" Deletes invitations sent to the current member account by Amazon Web Services accounts specified by their account IDs. """,
    tags=['invitation_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_invitations(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: InvitationDeletePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{resourceArn}',
    description=""" Lists tags for a resource. Tagging is currently supported for detectors, finding filters, IP sets, and threat intel sets, with a limit of 50 tags per resource. When invoked, this operation returns all assigned tags for a given resource. """,
    tags=['detector_management', 'detector_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: constr(
        pattern=r'^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\d+:detector/[A-Za-z0-9_/.-]{32,264}$'
    ) = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags/{resourceArn}',
    description=""" Adds tags to a resource. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'resource_tagging_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: constr(
        pattern=r'^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\d+:detector/[A-Za-z0-9_/.-]{32,264}$'
    ) = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{resourceArn}#tagKeys',
    description=""" Removes tags from a resource. """,
    tags=[
        'detector_management',
        'detector_configuration_management',
        'resource_tagging_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: constr(
        pattern=r'^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\d+:detector/[A-Za-z0-9_/.-]{32,264}$'
    ) = Path(..., alias='resourceArn'),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
